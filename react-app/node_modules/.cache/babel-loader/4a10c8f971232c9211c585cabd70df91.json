{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Represents an Item within LinkedList\r\n * An item holds a value and the links to other LinkedListItem's\r\n * LinkedListItem's can only be attached behind.\r\n * Theirfor, to add one before, before has to add one behind.\r\n */\n\nclass LinkedListItem {\n  constructor(value,\n  /**\r\n   * Called on unlink. Usually used by LinkedList to fix first and last pointers and reduce length.\r\n   */\n  unlinkCleanup) {\n    this.value = value;\n    this.unlinkCleanup = unlinkCleanup;\n  }\n  /**\r\n   * This will link given LinkListItem behind this item.\r\n   * If there's already a LinkedListItem linked behind, it will be relinked accordingly\r\n   * @param item LinkListItem to be inserted behind this one\r\n   */\n\n\n  insertBehind(item) {\n    item.insertBefore(this);\n\n    if (this.behind) {\n      let itemChainEnd = item;\n\n      while (itemChainEnd.behind) {\n        itemChainEnd = itemChainEnd.behind;\n      }\n\n      this.behind.insertBefore(itemChainEnd);\n      itemChainEnd.insertBehind(this.behind);\n    }\n\n    this.behind = item;\n  }\n  /**\r\n   * Unlinks this LinkedListItem and calls unlinkCleanup\r\n   * @see LinkedListItem#unlinkCleanup\r\n   */\n\n\n  unlink() {\n    if (this.before) {\n      this.before.behind = this.behind;\n    }\n\n    if (this.behind) {\n      this.behind.before = this.before;\n    }\n\n    if (this.unlinkCleanup) {\n      this.unlinkCleanup(this);\n    }\n\n    this.unlinkCleanup = undefined;\n  }\n  /**\r\n   * Item given will be inserted before this item.\r\n   * unlinkCleanup will be copied if neccessary.\r\n   * This function is protected, because LinkedListItem's can only be attached behind.\r\n   *\r\n   * @param before\r\n   * @see insertBehind\r\n   */\n\n\n  insertBefore(before) {\n    this.before = before;\n\n    if (!this.unlinkCleanup) {\n      this.unlinkCleanup = before.unlinkCleanup;\n    }\n  }\n\n}\n\nexports.LinkedListItem = LinkedListItem;","map":{"version":3,"sources":["../src/LinkedListItem.ts"],"names":[],"mappings":";;;;;AAAA;;;;;;;AAMA,MAAa,cAAb,CAA2B;AAezB,EAAA,WAAA,CACS,KADT;AAEE;;;AAGU,EAAA,aALZ,EAK6D;AAJpD,SAAA,KAAA,GAAA,KAAA;AAIG,SAAA,aAAA,GAAA,aAAA;AACR;AAEJ;;;;;;;AAKO,EAAA,YAAY,CAAC,IAAD,EAAwB;AACzC,IAAA,IAAI,CAAC,YAAL,CAAkB,IAAlB;;AAEA,QAAI,KAAK,MAAT,EAAiB;AACf,UAAI,YAAY,GAAG,IAAnB;;AACA,aAAO,YAAY,CAAC,MAApB,EAA4B;AAC1B,QAAA,YAAY,GAAG,YAAY,CAAC,MAA5B;AACD;;AACD,WAAK,MAAL,CAAY,YAAZ,CAAyB,YAAzB;AACA,MAAA,YAAY,CAAC,YAAb,CAA0B,KAAK,MAA/B;AACD;;AACD,SAAK,MAAL,GAAc,IAAd;AACD;AAED;;;;;;AAIO,EAAA,MAAM,GAAA;AACX,QAAI,KAAK,MAAT,EAAiB;AACf,WAAK,MAAL,CAAY,MAAZ,GAAqB,KAAK,MAA1B;AACD;;AACD,QAAI,KAAK,MAAT,EAAiB;AACf,WAAK,MAAL,CAAY,MAAZ,GAAqB,KAAK,MAA1B;AACD;;AACD,QAAI,KAAK,aAAT,EAAwB;AACtB,WAAK,aAAL,CAAmB,IAAnB;AACD;;AACD,SAAK,aAAL,GAAqB,SAArB;AACD;AAED;;;;;;;;;;AAQU,EAAA,YAAY,CAAC,MAAD,EAA0B;AAC9C,SAAK,MAAL,GAAc,MAAd;;AACA,QAAI,CAAC,KAAK,aAAV,EAAyB;AACvB,WAAK,aAAL,GAAqB,MAAM,CAAC,aAA5B;AACD;AACF;;AAxEwB;;AAA3B,OAAA,CAAA,cAAA,GAAA,cAAA","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Represents an Item within LinkedList\r\n * An item holds a value and the links to other LinkedListItem's\r\n * LinkedListItem's can only be attached behind.\r\n * Theirfor, to add one before, before has to add one behind.\r\n */\r\nclass LinkedListItem {\r\n    constructor(value, \r\n    /**\r\n     * Called on unlink. Usually used by LinkedList to fix first and last pointers and reduce length.\r\n     */\r\n    unlinkCleanup) {\r\n        this.value = value;\r\n        this.unlinkCleanup = unlinkCleanup;\r\n    }\r\n    /**\r\n     * This will link given LinkListItem behind this item.\r\n     * If there's already a LinkedListItem linked behind, it will be relinked accordingly\r\n     * @param item LinkListItem to be inserted behind this one\r\n     */\r\n    insertBehind(item) {\r\n        item.insertBefore(this);\r\n        if (this.behind) {\r\n            let itemChainEnd = item;\r\n            while (itemChainEnd.behind) {\r\n                itemChainEnd = itemChainEnd.behind;\r\n            }\r\n            this.behind.insertBefore(itemChainEnd);\r\n            itemChainEnd.insertBehind(this.behind);\r\n        }\r\n        this.behind = item;\r\n    }\r\n    /**\r\n     * Unlinks this LinkedListItem and calls unlinkCleanup\r\n     * @see LinkedListItem#unlinkCleanup\r\n     */\r\n    unlink() {\r\n        if (this.before) {\r\n            this.before.behind = this.behind;\r\n        }\r\n        if (this.behind) {\r\n            this.behind.before = this.before;\r\n        }\r\n        if (this.unlinkCleanup) {\r\n            this.unlinkCleanup(this);\r\n        }\r\n        this.unlinkCleanup = undefined;\r\n    }\r\n    /**\r\n     * Item given will be inserted before this item.\r\n     * unlinkCleanup will be copied if neccessary.\r\n     * This function is protected, because LinkedListItem's can only be attached behind.\r\n     *\r\n     * @param before\r\n     * @see insertBehind\r\n     */\r\n    insertBefore(before) {\r\n        this.before = before;\r\n        if (!this.unlinkCleanup) {\r\n            this.unlinkCleanup = before.unlinkCleanup;\r\n        }\r\n    }\r\n}\r\nexports.LinkedListItem = LinkedListItem;\r\n//# sourceMappingURL=LinkedListItem.js.map"]},"metadata":{},"sourceType":"script"}