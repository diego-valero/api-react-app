{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst LinkedListItem_1 = require(\"./LinkedListItem\");\n/**\r\n * Implements a linked list structure\r\n * @typeparam T Type of values within this LinkedList\r\n */\n\n\nclass LinkedList {\n  /**\r\n   * @param values Values to be added upfront into list\r\n   */\n  constructor(values) {\n    /**\r\n     * Current length of this LinkedList.\r\n     * Note that this does not work anymore if you for some reason add your own LinkedListItems to LinkedList by hand\r\n     */\n    this.length = 0;\n    /**\r\n     * Given to own LinkedListItem's for following jobs regarding an unlink:\r\n     * - If item is first item, set the next item as first item\r\n     * - If item is last item, set the previous item as last item\r\n     * - Decrease length\r\n     * @param item Item that has been unlinked\r\n     */\n\n    this.unlinkCleanup = item => {\n      if (this.first === item) {\n        this.first = this.first.behind;\n      }\n\n      if (this.last === item) {\n        this.last = this.last.before;\n      }\n\n      this.length--;\n    };\n\n    if (values) {\n      if (values instanceof LinkedList) {\n        values = values.values();\n      }\n\n      for (const value of values) {\n        this.push(value);\n      }\n    }\n  }\n  /**\r\n   * As Array#every() given callback is called for every element until one call returns falsy or all elements had been processed\r\n   * @returns `false` if there was a falsy response from the callback, `true` if all elements have been processed \"falselesly\"\r\n   * @see Array#every\r\n   */\n\n\n  every(callback, thisArg) {\n    if (thisArg) {\n      callback = callback.bind(thisArg);\n    }\n\n    for (const item of this.keys()) {\n      if (!callback(item.value, item, this)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\r\n   * Filters values into a new LinkedList\r\n   * @param callback decides wether given element should be part of new LinkedList\r\n   * @see Array#filter\r\n   */\n\n\n  filter(callback, thisArg) {\n    if (thisArg) {\n      callback = callback.bind(thisArg);\n    }\n\n    const newList = new LinkedList();\n\n    for (const [item, value] of this) {\n      if (callback(value, item, this)) {\n        newList.push(value);\n      }\n    }\n\n    return newList;\n  }\n  /**\r\n   * Returns value for which given callback returns truthy\r\n   * @param callback runs for every value in LinkedList. If it returns truthy, current value is returned.\r\n   * @see Array#find\r\n   */\n\n\n  find(callback, thisArg) {\n    if (thisArg) {\n      callback = callback.bind(thisArg);\n    }\n\n    for (const [item, value] of this) {\n      if (callback(value, item, this)) {\n        return value;\n      }\n    }\n  }\n  /**\r\n   * Returns the LinkedListItem for which given callback returns truthy\r\n   * @param callback runs for every LinkedListItem in LinkedList. If it returns truthy, current LinkedListItem is returned.\r\n   * @see Array#findIndex\r\n   */\n\n\n  findItem(callback, thisArg) {\n    if (thisArg) {\n      callback = callback.bind(thisArg);\n    }\n\n    for (const [item, value] of this) {\n      if (callback(value, item, this)) {\n        return item;\n      }\n    }\n  }\n  /**\r\n   * Iterates this LinkedList's items and values\r\n   * @param callback Gets every value in LinkedList once with corresponding LinkedListItem and LinkedList\r\n   * @param thisArg If given, callback will be bound here\r\n   * @see Array#forEach\r\n   */\n\n\n  forEach(callback, thisArg) {\n    if (thisArg) {\n      callback = callback.bind(thisArg);\n    }\n\n    for (const [item, value] of this) {\n      callback(value, item, this);\n    }\n  }\n  /**\r\n   * Checks if value can be found within LinkedList, starting from fromIndex, if given.\r\n   * @param value value to be found in this\r\n   * @param fromIndex Starting index. Supports negative values for which `this.size - 1 + fromIndex` will be used as starting point.\r\n   * @returns true if value could be found in LinkedList (respecting fromIndex), false otherwhise\r\n   * @see Array#includes\r\n   */\n\n\n  includes(value, fromIndex = 0) {\n    let current = this.getItemByIndex(fromIndex);\n\n    while (current) {\n      if (current.value === value) {\n        return true;\n      }\n\n      current = current.behind;\n    }\n\n    return false;\n  }\n  /**\r\n   * Searches forward for given value and returns the first corresponding LinkedListItem found\r\n   * @param searchedValue Value to be found\r\n   * @param fromIndex Index to start from\r\n   * @see Array#indexOf\r\n   */\n\n\n  itemOf(searchedValue, fromIndex = 0) {\n    let current = this.getItemByIndex(fromIndex);\n\n    while (current) {\n      if (current.value === searchedValue) {\n        return current;\n      }\n\n      current = current.behind;\n    }\n\n    return;\n  }\n  /**\r\n   * Searches backwards for given value and returns the first corresponding LinkedListItem found\r\n   * @param searchedValue Value to be found\r\n   * @param fromIndex Index to start from\r\n   * @see Array#indexOf\r\n   */\n\n\n  lastItemOf(searchedValue, fromIndex = -1) {\n    let current = this.getItemByIndex(fromIndex);\n\n    while (current) {\n      if (current.value === searchedValue) {\n        return current;\n      }\n\n      current = current.before;\n    }\n\n    return;\n  }\n  /**\r\n   * Creates a new LinkedList with each of its itesm representing the output of the callback with each item in current LinkedList.\r\n   * @param callback Gets value, LinkedListeItem and LinkedList. The response will be used as value in the new LinkedList\r\n   * @param thisArg If given, callback is bound to thisArg\r\n   * @see Array#map\r\n   */\n\n\n  map(callback, thisArg) {\n    if (thisArg) {\n      callback = callback.bind(thisArg);\n    }\n\n    const newList = new LinkedList();\n\n    for (const [item, value] of this) {\n      newList.push(callback(value, item, this));\n    }\n\n    return newList;\n  }\n\n  reduce(callback, initialValue) {\n    let current = this.first;\n\n    if (!current) {\n      if (!initialValue) {\n        throw new TypeError(\"Empty accumulator on empty LinkedList is not allowed.\");\n      }\n\n      return initialValue;\n    }\n\n    if (initialValue === undefined) {\n      initialValue = current.value;\n\n      if (!current.behind) {\n        return initialValue;\n      }\n\n      current = current.behind;\n    } else {\n      initialValue = initialValue;\n    }\n\n    do {\n      initialValue = callback(initialValue, current.value, current, this);\n      current = current.behind;\n    } while (current);\n\n    return initialValue;\n  }\n\n  reduceRight(callback, initialValue) {\n    let current = this.last;\n\n    if (!current) {\n      if (!initialValue) {\n        throw new TypeError(\"Empty accumulator on empty LinkedList is not allowed.\");\n      }\n\n      return initialValue;\n    } // let accumulator: V | T;\n\n\n    if (initialValue === undefined) {\n      initialValue = current.value;\n\n      if (!current.before) {\n        return initialValue;\n      }\n\n      current = current.before;\n    } else {\n      initialValue = initialValue;\n    }\n\n    do {\n      initialValue = callback(initialValue, current.value, current, this);\n      current = current.before;\n    } while (current);\n\n    return initialValue;\n  }\n  /**\r\n   * Runs callback for every entry and returns true immediately if call of callback returns truthy.\r\n   * @param callback called for every element. If response is truthy, iteration\r\n   * @param thisArg If set, callback is bound to this\r\n   * @returns `true` once a callback call returns truthy, `false` if none returned truthy.\r\n   */\n\n\n  some(callback, thisArg) {\n    if (thisArg) {\n      callback = callback.bind(thisArg);\n    }\n\n    for (const [item, value] of this) {\n      if (callback(value, item, this)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\r\n   * Joins values within this by given separator. Uses Array#join directly.\r\n   * @param separator separator to be used\r\n   * @see Array#join\r\n   */\n\n\n  join(separator) {\n    return [...this.values()].join(separator);\n  }\n  /**\r\n   * Concats given values and returns a new LinkedList with all given values.\r\n   * If LinkedList's are given, they will be spread.\r\n   * @param others Other values or lists to be concat'ed together\r\n   * @see Array#concat\r\n   */\n\n\n  concat(...others) {\n    const newList = new LinkedList(this);\n\n    for (const other of others) {\n      if (other instanceof LinkedList) {\n        newList.push(...other.values());\n      } else {\n        newList.push(other);\n      }\n    }\n\n    return newList;\n  }\n  /**\r\n   * Removes the last LinkedListItem and returns its inner value\r\n   */\n\n\n  pop() {\n    if (!this.last) {\n      return;\n    }\n\n    const item = this.last;\n    item.unlink();\n    return item.value;\n  }\n  /**\r\n   * Adds given values on the end of this LinkedList\r\n   * @param values Values to be added\r\n   */\n\n\n  push(...values) {\n    for (const value of values) {\n      const item = new LinkedListItem_1.LinkedListItem(value, this.unlinkCleanup);\n\n      if (!this.first || !this.last) {\n        this.first = this.last = item;\n      } else {\n        this.last.insertBehind(item);\n        this.last = item;\n      }\n\n      this.length++;\n    }\n  }\n  /**\r\n   * Adds given values to the beginning of this LinkedList\r\n   * @param values Values to be added\r\n   */\n\n\n  unshift(...values) {\n    for (const value of values) {\n      const item = new LinkedListItem_1.LinkedListItem(value, this.unlinkCleanup);\n\n      if (!this.last || !this.first) {\n        this.first = this.last = item;\n      } else {\n        item.insertBehind(this.first);\n        this.first = item;\n      }\n\n      this.length++;\n    }\n  }\n  /**\r\n   * Removes first occurrence of value found.\r\n   * @param value value to remove from LinkedList\r\n   */\n\n\n  remove(value) {\n    for (const item of this.keys()) {\n      if (item.value === value) {\n        item.unlink();\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\r\n   * Removes every occurrance of value within this.\r\n   * @param value value to remove from LinkedList\r\n   */\n\n\n  removeAllOccurrences(value) {\n    let foundSomethingToDelete = false;\n\n    for (const item of this.keys()) {\n      if (item.value === value) {\n        item.unlink();\n        foundSomethingToDelete = true;\n      }\n    }\n\n    return foundSomethingToDelete;\n  }\n  /**\r\n   * Returns and removes first element from LinkedList\r\n   */\n\n\n  shift() {\n    if (!this.first) {\n      return;\n    }\n\n    const item = this.first;\n    item.unlink();\n    return item.value;\n  }\n  /**\r\n   * Returns LinkedListItem and value for every entry of this LinkedList\r\n   */\n\n\n  *[Symbol.iterator]() {\n    let current = this.first;\n\n    if (!current) {\n      return;\n    }\n\n    do {\n      yield [current, current.value];\n      current = current.behind;\n    } while (current);\n  }\n  /**\r\n   * Returns LinkedListItem and value for every entry of this LinkedList\r\n   * @see LinkedList#Symbol.iterator\r\n   */\n\n\n  entries() {\n    return this[Symbol.iterator]();\n  }\n  /**\r\n   * Iterates the LinkedListItem's of this LinkedList\r\n   */\n\n\n  *keys() {\n    let current = this.first;\n\n    if (!current) {\n      return;\n    }\n\n    do {\n      yield current;\n      current = current.behind;\n    } while (current);\n  }\n  /**\r\n   * Returns a value for every entry of this LinkedList\r\n   */\n\n\n  *values() {\n    let current = this.first;\n\n    if (!current) {\n      return;\n    }\n\n    do {\n      yield current.value;\n      current = current.behind;\n    } while (current);\n  }\n  /**\r\n   * Returns the item by given index.\r\n   * Supports negative values and will return the item at `LinkedList.size - 1 + index` in that case.\r\n   * @param index Index of item to get from list\r\n   */\n\n\n  getItemByIndex(index) {\n    if (index === undefined) {\n      throw new Error(\"index must be a number!\");\n    }\n\n    if (!this.first) {\n      return;\n    }\n\n    let current;\n\n    if (index > 0) {\n      current = this.first;\n\n      while (current && index--) {\n        current = current.behind;\n      }\n    } else if (index < 0) {\n      current = this.last;\n\n      while (current && ++index) {\n        current = current.before;\n      }\n    } else {\n      return this.first;\n    }\n\n    return current;\n  }\n\n}\n\nexports.LinkedList = LinkedList;","map":{"version":3,"sources":["../src/LinkedList.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst LinkedListItem_1 = require(\"./LinkedListItem\");\r\n/**\r\n * Implements a linked list structure\r\n * @typeparam T Type of values within this LinkedList\r\n */\r\nclass LinkedList {\r\n    /**\r\n     * @param values Values to be added upfront into list\r\n     */\r\n    constructor(values) {\r\n        /**\r\n         * Current length of this LinkedList.\r\n         * Note that this does not work anymore if you for some reason add your own LinkedListItems to LinkedList by hand\r\n         */\r\n        this.length = 0;\r\n        /**\r\n         * Given to own LinkedListItem's for following jobs regarding an unlink:\r\n         * - If item is first item, set the next item as first item\r\n         * - If item is last item, set the previous item as last item\r\n         * - Decrease length\r\n         * @param item Item that has been unlinked\r\n         */\r\n        this.unlinkCleanup = (item) => {\r\n            if (this.first === item) {\r\n                this.first = this.first.behind;\r\n            }\r\n            if (this.last === item) {\r\n                this.last = this.last.before;\r\n            }\r\n            this.length--;\r\n        };\r\n        if (values) {\r\n            if (values instanceof LinkedList) {\r\n                values = values.values();\r\n            }\r\n            for (const value of values) {\r\n                this.push(value);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * As Array#every() given callback is called for every element until one call returns falsy or all elements had been processed\r\n     * @returns `false` if there was a falsy response from the callback, `true` if all elements have been processed \"falselesly\"\r\n     * @see Array#every\r\n     */\r\n    every(callback, thisArg) {\r\n        if (thisArg) {\r\n            callback = callback.bind(thisArg);\r\n        }\r\n        for (const item of this.keys()) {\r\n            if (!callback(item.value, item, this)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Filters values into a new LinkedList\r\n     * @param callback decides wether given element should be part of new LinkedList\r\n     * @see Array#filter\r\n     */\r\n    filter(callback, thisArg) {\r\n        if (thisArg) {\r\n            callback = callback.bind(thisArg);\r\n        }\r\n        const newList = new LinkedList();\r\n        for (const [item, value] of this) {\r\n            if (callback(value, item, this)) {\r\n                newList.push(value);\r\n            }\r\n        }\r\n        return newList;\r\n    }\r\n    /**\r\n     * Returns value for which given callback returns truthy\r\n     * @param callback runs for every value in LinkedList. If it returns truthy, current value is returned.\r\n     * @see Array#find\r\n     */\r\n    find(callback, thisArg) {\r\n        if (thisArg) {\r\n            callback = callback.bind(thisArg);\r\n        }\r\n        for (const [item, value] of this) {\r\n            if (callback(value, item, this)) {\r\n                return value;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Returns the LinkedListItem for which given callback returns truthy\r\n     * @param callback runs for every LinkedListItem in LinkedList. If it returns truthy, current LinkedListItem is returned.\r\n     * @see Array#findIndex\r\n     */\r\n    findItem(callback, thisArg) {\r\n        if (thisArg) {\r\n            callback = callback.bind(thisArg);\r\n        }\r\n        for (const [item, value] of this) {\r\n            if (callback(value, item, this)) {\r\n                return item;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Iterates this LinkedList's items and values\r\n     * @param callback Gets every value in LinkedList once with corresponding LinkedListItem and LinkedList\r\n     * @param thisArg If given, callback will be bound here\r\n     * @see Array#forEach\r\n     */\r\n    forEach(callback, thisArg) {\r\n        if (thisArg) {\r\n            callback = callback.bind(thisArg);\r\n        }\r\n        for (const [item, value] of this) {\r\n            callback(value, item, this);\r\n        }\r\n    }\r\n    /**\r\n     * Checks if value can be found within LinkedList, starting from fromIndex, if given.\r\n     * @param value value to be found in this\r\n     * @param fromIndex Starting index. Supports negative values for which `this.size - 1 + fromIndex` will be used as starting point.\r\n     * @returns true if value could be found in LinkedList (respecting fromIndex), false otherwhise\r\n     * @see Array#includes\r\n     */\r\n    includes(value, fromIndex = 0) {\r\n        let current = this.getItemByIndex(fromIndex);\r\n        while (current) {\r\n            if (current.value === value) {\r\n                return true;\r\n            }\r\n            current = current.behind;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Searches forward for given value and returns the first corresponding LinkedListItem found\r\n     * @param searchedValue Value to be found\r\n     * @param fromIndex Index to start from\r\n     * @see Array#indexOf\r\n     */\r\n    itemOf(searchedValue, fromIndex = 0) {\r\n        let current = this.getItemByIndex(fromIndex);\r\n        while (current) {\r\n            if (current.value === searchedValue) {\r\n                return current;\r\n            }\r\n            current = current.behind;\r\n        }\r\n        return;\r\n    }\r\n    /**\r\n     * Searches backwards for given value and returns the first corresponding LinkedListItem found\r\n     * @param searchedValue Value to be found\r\n     * @param fromIndex Index to start from\r\n     * @see Array#indexOf\r\n     */\r\n    lastItemOf(searchedValue, fromIndex = -1) {\r\n        let current = this.getItemByIndex(fromIndex);\r\n        while (current) {\r\n            if (current.value === searchedValue) {\r\n                return current;\r\n            }\r\n            current = current.before;\r\n        }\r\n        return;\r\n    }\r\n    /**\r\n     * Creates a new LinkedList with each of its itesm representing the output of the callback with each item in current LinkedList.\r\n     * @param callback Gets value, LinkedListeItem and LinkedList. The response will be used as value in the new LinkedList\r\n     * @param thisArg If given, callback is bound to thisArg\r\n     * @see Array#map\r\n     */\r\n    map(callback, thisArg) {\r\n        if (thisArg) {\r\n            callback = callback.bind(thisArg);\r\n        }\r\n        const newList = new LinkedList();\r\n        for (const [item, value] of this) {\r\n            newList.push(callback(value, item, this));\r\n        }\r\n        return newList;\r\n    }\r\n    reduce(callback, initialValue) {\r\n        let current = this.first;\r\n        if (!current) {\r\n            if (!initialValue) {\r\n                throw new TypeError(\"Empty accumulator on empty LinkedList is not allowed.\");\r\n            }\r\n            return initialValue;\r\n        }\r\n        if (initialValue === undefined) {\r\n            initialValue = current.value;\r\n            if (!current.behind) {\r\n                return initialValue;\r\n            }\r\n            current = current.behind;\r\n        }\r\n        else {\r\n            initialValue = initialValue;\r\n        }\r\n        do {\r\n            initialValue = callback(initialValue, current.value, current, this);\r\n            current = current.behind;\r\n        } while (current);\r\n        return initialValue;\r\n    }\r\n    reduceRight(callback, initialValue) {\r\n        let current = this.last;\r\n        if (!current) {\r\n            if (!initialValue) {\r\n                throw new TypeError(\"Empty accumulator on empty LinkedList is not allowed.\");\r\n            }\r\n            return initialValue;\r\n        }\r\n        // let accumulator: V | T;\r\n        if (initialValue === undefined) {\r\n            initialValue = current.value;\r\n            if (!current.before) {\r\n                return initialValue;\r\n            }\r\n            current = current.before;\r\n        }\r\n        else {\r\n            initialValue = initialValue;\r\n        }\r\n        do {\r\n            initialValue = callback(initialValue, current.value, current, this);\r\n            current = current.before;\r\n        } while (current);\r\n        return initialValue;\r\n    }\r\n    /**\r\n     * Runs callback for every entry and returns true immediately if call of callback returns truthy.\r\n     * @param callback called for every element. If response is truthy, iteration\r\n     * @param thisArg If set, callback is bound to this\r\n     * @returns `true` once a callback call returns truthy, `false` if none returned truthy.\r\n     */\r\n    some(callback, thisArg) {\r\n        if (thisArg) {\r\n            callback = callback.bind(thisArg);\r\n        }\r\n        for (const [item, value] of this) {\r\n            if (callback(value, item, this)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Joins values within this by given separator. Uses Array#join directly.\r\n     * @param separator separator to be used\r\n     * @see Array#join\r\n     */\r\n    join(separator) {\r\n        return [...this.values()].join(separator);\r\n    }\r\n    /**\r\n     * Concats given values and returns a new LinkedList with all given values.\r\n     * If LinkedList's are given, they will be spread.\r\n     * @param others Other values or lists to be concat'ed together\r\n     * @see Array#concat\r\n     */\r\n    concat(...others) {\r\n        const newList = new LinkedList(this);\r\n        for (const other of others) {\r\n            if (other instanceof LinkedList) {\r\n                newList.push(...other.values());\r\n            }\r\n            else {\r\n                newList.push(other);\r\n            }\r\n        }\r\n        return newList;\r\n    }\r\n    /**\r\n     * Removes the last LinkedListItem and returns its inner value\r\n     */\r\n    pop() {\r\n        if (!this.last) {\r\n            return;\r\n        }\r\n        const item = this.last;\r\n        item.unlink();\r\n        return item.value;\r\n    }\r\n    /**\r\n     * Adds given values on the end of this LinkedList\r\n     * @param values Values to be added\r\n     */\r\n    push(...values) {\r\n        for (const value of values) {\r\n            const item = new LinkedListItem_1.LinkedListItem(value, this.unlinkCleanup);\r\n            if (!this.first || !this.last) {\r\n                this.first = this.last = item;\r\n            }\r\n            else {\r\n                this.last.insertBehind(item);\r\n                this.last = item;\r\n            }\r\n            this.length++;\r\n        }\r\n    }\r\n    /**\r\n     * Adds given values to the beginning of this LinkedList\r\n     * @param values Values to be added\r\n     */\r\n    unshift(...values) {\r\n        for (const value of values) {\r\n            const item = new LinkedListItem_1.LinkedListItem(value, this.unlinkCleanup);\r\n            if (!this.last || !this.first) {\r\n                this.first = this.last = item;\r\n            }\r\n            else {\r\n                item.insertBehind(this.first);\r\n                this.first = item;\r\n            }\r\n            this.length++;\r\n        }\r\n    }\r\n    /**\r\n     * Removes first occurrence of value found.\r\n     * @param value value to remove from LinkedList\r\n     */\r\n    remove(value) {\r\n        for (const item of this.keys()) {\r\n            if (item.value === value) {\r\n                item.unlink();\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Removes every occurrance of value within this.\r\n     * @param value value to remove from LinkedList\r\n     */\r\n    removeAllOccurrences(value) {\r\n        let foundSomethingToDelete = false;\r\n        for (const item of this.keys()) {\r\n            if (item.value === value) {\r\n                item.unlink();\r\n                foundSomethingToDelete = true;\r\n            }\r\n        }\r\n        return foundSomethingToDelete;\r\n    }\r\n    /**\r\n     * Returns and removes first element from LinkedList\r\n     */\r\n    shift() {\r\n        if (!this.first) {\r\n            return;\r\n        }\r\n        const item = this.first;\r\n        item.unlink();\r\n        return item.value;\r\n    }\r\n    /**\r\n     * Returns LinkedListItem and value for every entry of this LinkedList\r\n     */\r\n    *[Symbol.iterator]() {\r\n        let current = this.first;\r\n        if (!current) {\r\n            return;\r\n        }\r\n        do {\r\n            yield [current, current.value];\r\n            current = current.behind;\r\n        } while (current);\r\n    }\r\n    /**\r\n     * Returns LinkedListItem and value for every entry of this LinkedList\r\n     * @see LinkedList#Symbol.iterator\r\n     */\r\n    entries() {\r\n        return this[Symbol.iterator]();\r\n    }\r\n    /**\r\n     * Iterates the LinkedListItem's of this LinkedList\r\n     */\r\n    *keys() {\r\n        let current = this.first;\r\n        if (!current) {\r\n            return;\r\n        }\r\n        do {\r\n            yield current;\r\n            current = current.behind;\r\n        } while (current);\r\n    }\r\n    /**\r\n     * Returns a value for every entry of this LinkedList\r\n     */\r\n    *values() {\r\n        let current = this.first;\r\n        if (!current) {\r\n            return;\r\n        }\r\n        do {\r\n            yield current.value;\r\n            current = current.behind;\r\n        } while (current);\r\n    }\r\n    /**\r\n     * Returns the item by given index.\r\n     * Supports negative values and will return the item at `LinkedList.size - 1 + index` in that case.\r\n     * @param index Index of item to get from list\r\n     */\r\n    getItemByIndex(index) {\r\n        if (index === undefined) {\r\n            throw new Error(\"index must be a number!\");\r\n        }\r\n        if (!this.first) {\r\n            return;\r\n        }\r\n        let current;\r\n        if (index > 0) {\r\n            current = this.first;\r\n            while (current && index--) {\r\n                current = current.behind;\r\n            }\r\n        }\r\n        else if (index < 0) {\r\n            current = this.last;\r\n            while (current && ++index) {\r\n                current = current.before;\r\n            }\r\n        }\r\n        else {\r\n            return this.first;\r\n        }\r\n        return current;\r\n    }\r\n}\r\nexports.LinkedList = LinkedList;\r\n//# sourceMappingURL=LinkedList.js.map"]},"metadata":{},"sourceType":"script"}